<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库范式</title>
      <link href="/posts/91a921e9.html"/>
      <url>/posts/91a921e9.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式 1NF"></a>第一范式 1NF</h2><blockquote><p>强调的是列的原子性，即列不能够再分成其他几列。<br>考虑这样一个表：[联系人] (姓名，性别，电话)<br>如果在实际场景中，一个联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF。<br>要符合 1NF，我们只需把列(电话)拆分，即：[联系人] (姓名,性别,家庭电话,公司电话). 1NF 很好辨别,但是 2NF 和 3NF 就容易搞混淆.</p></blockquote><h2 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式 2NF"></a>第二范式 2NF</h2><blockquote><p><strong>首先是 1NF</strong>，另外包含两部分内容，<strong>一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分</strong>.<br>考虑一个订单明细表：[OrderDetail]（OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName）。<br>因为我们知道在一个订单中可以订购多种产品，所以单单一个 OrderID 是不足以成为主键的，主键应该是(OrderID，ProductID).<br>显而易见Discount,Quantity,完全依赖于主键(OderID,ProductID),而UnitPrice,ProductName<br>只依赖于 ProductID。所以 OrderDetail 表不符合 2NF。不符合 2NF 的设计容易产生冗余数据。<br>可以把[OrderDetail]表拆分为[OrderDetail]（OrderID，ProductID，Discount，Quantity）和[Product]（ProductID，UnitPrice，ProductName）来消除原订单表中UnitPrice，ProductName多次重复的情况。</p></blockquote><h2 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式 3NF"></a>第三范式 3NF</h2><blockquote><p><strong>首先是 2NF</strong>，另外非主键列必须直接依赖于主键，不能存在传递依赖。即<strong>不能存在：非主键列 A 依赖于非主键列 B，非主键列 B依赖于主键的情况</strong>。考虑一个订单表[Order] (OrderID,OrderDate,CustomerID,CustomerName,CustomerAddr,CustomerCity)主键是(OrderID)其中 OrderDate,CustomerID,CustomerName,CustomerAddr,CustomerCity等非主键列都完全依赖于主键(OrderID),所以符合2NF. 不过问题是CustomerName,CustomerAddr,CustomerCity直接依赖的是CustomerID(非主键列),而不是直接依赖于主键,它是通过传递才依赖于主键,所以不符合 3NF。通过拆分[Order]为[Order]（OrderID，OrderDate，CustomerID）和[Customer]（CustomerID，CustomerName，CustomerAddr，CustomerCity）从而达到 3NF。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库学习</title>
      <link href="/posts/b4fe5633.html"/>
      <url>/posts/b4fe5633.html</url>
      
        <content type="html"><![CDATA[<h2 id="排序与分页"><a href="#排序与分页" class="headerlink" title="排序与分页"></a>排序与分页</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 多列排序</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,salary,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id <span class="keyword">DESC</span>,salary <span class="keyword">ASC</span></span><br></pre></td></tr></table></figure><div class="note default flat"><p>在对多列进⾏排序的时候，⾸先排序的第⼀列必须有相同的列值，才会对第⼆列进⾏排序。如果第⼀<br>列数据中所有值都是唯⼀的，将不再对第⼆列进⾏排序。</p></div><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 LIMIT <span class="number">20</span>,<span class="number">10</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">10</span>;(Mysql <span class="operator">&gt;</span> <span class="number">8.0</span>)</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>深分页该怎么办</p></div><hr><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="等值连接VS非等值连接"><a href="#等值连接VS非等值连接" class="headerlink" title="等值连接VS非等值连接"></a>等值连接VS非等值连接</h4><div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tab-1">等值连接</button></li><li class="tab"><button type="button" data-href="#tab-2">非等值连接</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tab-1"><p>等值连接（Equi-Join）基于两个表之间的相等匹配条件来组合它们的行,通常使用在需要从两个表中选择相关数据的查询中。</p><p>等值连接使用一个等于号（=）来比较两个表中的列。当两个表中的列具有相同的值时，它们的行就会被组合在一起。例如，下面的 SQL 查询使用等值连接来将 “orders” 表中的 “customer_id” 列与 “customers” 表中的 “customer_id” 列匹配：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">JOIN</span> customers</span><br><span class="line"><span class="keyword">ON</span> orders.customer_id <span class="operator">=</span> customers.customer_id;</span><br></pre></td></tr></table></figure><p>这将返回一个包含 “orders” 表和 “customers” 表中匹配 “customer_id” 的行的结果集。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tab-2"><p>非等值连接（Non-Equi Join）基于两个表之间的不等匹配条件来组合它们的行,通常使用在需要从两个表中选择相关数据的查询中。</p><p>非等值连接使用不等于号（&lt;&gt;、!=、&lt;、&gt;、&lt;=、&gt;=）等比较运算符来比较两个表中的列。当两个表中的列不具有相同的值时，它们的行就会被组合在一起。例如，下面的 SQL 查询使用非等值连接来将 “orders” 表中的 “order_date” 列与 “calendar” 表中的 “date” 列匹配：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">JOIN</span> calendar</span><br><span class="line"><span class="keyword">ON</span> orders.order_date <span class="keyword">BETWEEN</span> calendar.date <span class="keyword">AND</span> calendar.date <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，”orders” 表中的 “order_date” 列被匹配到了 “calendar” 表中的 “date” 列和 “date” + INTERVAL 1 DAY 列之间的范围内。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p><mark class="hl-label blue">拓展1：</mark> 区分重复的列名</p><ol><li>多个表中有相同列时，必须在列名之前加上表名前缀。</li></ol><p><mark class="hl-label blue">拓展2：</mark> 表的别名</p><ol><li>使⽤别名可以<mark class="hl-label green">简化查询</mark> 。</li><li>列名前使⽤表名前缀可以<mark class="hl-label green">提⾼查询效率</mark> 。</li></ol><p><mark class="hl-label blue">拓展3：</mark> 连接多个表</p><ol><li>连接n个表<mark class="hl-label red">⾄少需要n-1个连接条件</mark> 。</li></ol></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name,e.salary,j.grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees e,job_grades j</span><br><span class="line"><span class="keyword">WHERE</span> e.`salary` <span class="operator">&gt;=</span> j.`lowest_sal` <span class="keyword">AND</span> e.`salary` <span class="operator">&lt;=</span> j.`highest_sal`;</span><br></pre></td></tr></table></figure><hr><h4 id="自连接VS非自连接"><a href="#自连接VS非自连接" class="headerlink" title="自连接VS非自连接"></a>自连接VS非自连接</h4><div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tab-1">自连接</button></li><li class="tab"><button type="button" data-href="#tab-2">非自连接</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tab-1"><p>自连接（Self Join）是指将一个表与自身进行连接。自连接通常用于需要在同一表中比较或匹配不同行的情况。</p><p>自连接可以通过给表指定不同的别名来实现。例如，下面的 SQL 查询使用自连接来查找 “employees” 表中每个员工的经理：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.employee_name, m.employee_name <span class="keyword">AS</span> manager_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> employees m</span><br><span class="line"><span class="keyword">ON</span> e.manager_id <span class="operator">=</span> m.employee_id;</span><br></pre></td></tr></table></figure><p>在这个例子中，”employees” 表被自连接为两个不同的实例，分别用 “e” 和 “m” 作为别名。连接条件是 “e.manager_id = m.employee_id”，它将 “employees” 表中的每个员工与其对应的经理匹配。这将返回一个包含每个员工姓名和其经理姓名的结果集。</p><p>需要注意的是，在进行自连接时，需要确保连接条件不会将同一行与自身进行匹配，否则可能会导致无限循环或错误的结果。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tab-2"><p>非自连接可以使用各种连接类型，例如内连接（Inner Join）、左连接（Left Join）、右连接（Right Join）和全连接（Full Join），具体取决于需要的结果集。连接条件通常是两个表中的列之间的相等匹配条件。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="内连接VS外连接"><a href="#内连接VS外连接" class="headerlink" title="内连接VS外连接"></a>内连接VS外连接</h4><ul><li>内连接: 合并具有同⼀列的两个以上的表的⾏, 结果集中不包含⼀个表与另⼀个表不匹配的⾏</li><li>外连接: 两个表在连接过程中除了返回满⾜连接条件的⾏以外还返回左（或右）表中不满⾜条件的⾏，<br>这种连接称为左（或右） 外连接。没有匹配的⾏时, 结果表中相应的列为空(NULL)。<br>如果是左外连接，则连接条件中左边的表也称为 主表 ，右边的表称为 从表 。<br>如果是右外连接，则连接条件中右边的表也称为 主表 ，左边的表称为 从表 。</li></ul><blockquote><p>在使用 left jion 时，on 和 where 条件的区别如下：<br>1、on 条件是在生成临时表时使用的条件，它不管 on 中的条件是否为真，都会返回左边表中的记录。<br>2、where 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 left join 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</p></blockquote><h2 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h2><p>TODO</p><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><div class="note info flat"><p>聚合函数（Aggregate Function）是一组用于计算多个行的值并返回单个值的函数。聚合函数通常用于统计和分析数据，例如计算平均值、最大值、最小值、总和等。</p></div><h3 id="AVG-SUM-MIN-MAX函数函数"><a href="#AVG-SUM-MIN-MAX函数函数" class="headerlink" title="AVG/SUM/MIN/MAX函数函数"></a>AVG/SUM/MIN/MAX函数函数</h3><blockquote><p>下面的 SQL 查询使用 AVG 函数计算 “employees” 表中所有员工的平均工资：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(salary),SUM(salary),MIN(salary),MAX(salary)</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><br>在这个例子中，AVG 函数计算 “employees” 表中所有员工的工资平均值，并将结果作为单个值返回。</p></blockquote><h3 id="COUNT函数"><a href="#COUNT函数" class="headerlink" title="COUNT函数"></a>COUNT函数</h3><blockquote><p>COUNT(*)返回表中记录总数，适⽤于任意数据类型。<br>COUNT(expr) 返回expr不为NULL的记录总数。</p></blockquote><h3 id="Group-By函数"><a href="#Group-By函数" class="headerlink" title="Group By函数"></a>Group By函数</h3><h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>领域驱动设计</title>
      <link href="/posts/209eb15b.html"/>
      <url>/posts/209eb15b.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习领域驱动设计的笔记</p></blockquote><h3 id="领域"><a href="#领域" class="headerlink" title="领域"></a>领域</h3><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> 领域驱动设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDD </tag>
            
            <tag> 领域驱动设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于</p></blockquote>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/modify.css"/>
      <url>/css/modify.css</url>
      
        <content type="html"><![CDATA[#page-header,#page-header:before {  background: transparent !important;}#page-header.post-bg,#page-header.not-home-page {  height: 280px !important;}#page-header #post-info {  bottom: 40px !important;}#page-header #page-site-info {  top: 140px !important;}@media screen and (max-width: 768px) {  #page-header.not-home-page {    height: 200px !important;  }  #page-header #post-info {    bottom: 10px !important;  }  #page-header #page-site-info {    top: 100px !important;  }}.top-img {  height: 250px;  margin: -50px -40px 50px;  border-top-left-radius: inherit;  border-top-right-radius: inherit;  background-position: center center;  background-size: cover;  -webkit-transition: all 0.3s;  -moz-transition: all 0.3s;  -o-transition: all 0.3s;  -ms-transition: all 0.3s;  transition: all 0.3s;}@media screen and (max-width: 768px) {  .top-img {    height: 230px;    margin: -36px -14px 36px;  }}[data-theme='dark'] .top-img {  filter: brightness(0.8);}#footer:before {  background-color: rgba(255,255,255,0.5);}[data-theme='dark'] #footer:before {  background-color: rgba(0,0,0,0.5);}#footer-wrap,#footer-wrap a {  color: #111;  -webkit-transition: unset;  -moz-transition: unset;  -o-transition: unset;  -ms-transition: unset;  transition: unset;}[data-theme='dark'] #footer-wrap,[data-theme='dark'] #footer-wrap a {  color: var(--light-grey);}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[setInterval(() => {    let create_time = Math.round(new Date('2023-06-11 00:00:00').getTime() / 1000); //在此行修改建站时间    let timestamp = Math.round((new Date().getTime()) / 1000);    let second = timestamp - create_time;    let time = new Array(0, 0, 0, 0, 0);      var nol = function(h){      return h>9?h:'0'+h;    }    if (second >= 365 * 24 * 3600) {      time[0] = parseInt(second / (365 * 24 * 3600));      second %= 365 * 24 * 3600;    }    if (second >= 24 * 3600) {      time[1] = parseInt(second / (24 * 3600));      second %= 24 * 3600;    }    if (second >= 3600) {      time[2] = nol(parseInt(second / 3600));      second %= 3600;    }    if (second >= 60) {      time[3] = nol(parseInt(second / 60));      second %= 60;    }    if (second > 0) {      time[4] = nol(second);    }    if ((Number(time[2])<22) && (Number(time[2])>7)){      currentTimeHtml ="<img class='boardsign' src='https://img.shields.io/badge/Splay-营业中-6adea8?style=social&logo=cakephp' title='距离百年老店也就差不到一百年~'><div id='runtime'>" + time[0] + ' YEAR ' + time[1] + ' DAYS ' + time[2] + ' : ' + time[3] + ' : ' + time[4] + '</div>';    }    else{      currentTimeHtml ="<img class='boardsign' src='https://img.shields.io/badge/Splay-打烊了-6adea8?style=social&logo=coffeescript' title='这个点了应该去睡觉啦，熬夜对身体不好哦'><div id='runtime'>" + time[0] + ' YEAR ' + time[1] + ' DAYS ' + time[2] + ' : ' + time[3] + ' : ' + time[4] + '</div>';    }    document.getElementById("workboard").innerHTML = currentTimeHtml;  }, 1000);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
