<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>备忘录之CodeFirst</title>
      <link href="/posts/d708680b.html"/>
      <url>/posts/d708680b.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近老是忘掉CodeFirst咋写, 于是写一下记录一下</p></blockquote><h2 id="先写实体类"><a href="#先写实体类" class="headerlink" title="先写实体类"></a>先写实体类</h2><h2 id="添加Nuget包引用"><a href="#添加Nuget包引用" class="headerlink" title="添加Nuget包引用"></a>添加Nuget包引用</h2><ol><li>Microsoft.EntityFramework</li><li>Microsoft.EntityFramework.Tool (使用EFCore命令行需要使用的库)</li><li>Microsoft.EntityFramework.Relational (配置关系时需要的包)</li><li>Microsoft.EntityFramework.SqlServer (使用SqlServer数据库)</li></ol><h2 id="创建DbContext"><a href="#创建DbContext" class="headerlink" title="创建DbContext"></a>创建DbContext</h2><p>创建一个DbContext继承自DbContext<br>构造函数继承父类的</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LotteryDbContext</span>(<span class="params">DbContextOptions&lt;LotteryDbContext&gt; opt</span>): <span class="title">base</span>(<span class="params">opt</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写一下OnModelCreating方法<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">    modelBuilder.ConfigureModel(); <span class="comment">// 自定义的扩展方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ConfigureModel</span>(<span class="params"><span class="keyword">this</span> ModelBuilder builder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里配置关系 eg:</span></span><br><span class="line">    builder.Entity&lt;类名&gt;(b =&gt; &#123;</span><br><span class="line">        b.ToTable(<span class="string">&quot;表名&quot;</span>, _ =&gt; _.HasComment(<span class="string">&quot;表的注释&quot;</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在Program-cs里面注册DbContext"><a href="#在Program-cs里面注册DbContext" class="headerlink" title="在Program.cs里面注册DbContext"></a>在Program.cs里面注册DbContext</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生EFCore的配置方式</span></span><br><span class="line">builder.Services.AddDbContext&lt;LotteryDbContext&gt;((sp, optionsBuilder) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可以自定义拦截器</span></span><br><span class="line">    <span class="comment">// var addOrUpdateInterceptor = sp.GetService&lt;AddOrUpdateInterceptor&gt;();</span></span><br><span class="line">    optionsBuilder.UseSqlServer(builder.Configuration.GetConnectionString(<span class="string">&quot;配置Key&quot;</span>)); <span class="comment">// 从配置文件的Connection中读取Lottery</span></span><br><span class="line">        <span class="comment">// .AddInterceptors(addOrUpdateInterceptor!);</span></span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure><p>在application.json文件中添加连接字符串<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;ConnectionStrings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;配置Key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Server=localhost;Database=数据库名;Trusted_Connection=True;TrustServerCertificate=True;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="直接使用插件或者命令行生成数据库"><a href="#直接使用插件或者命令行生成数据库" class="headerlink" title="直接使用插件或者命令行生成数据库"></a>直接使用插件或者命令行生成数据库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Migrations Init</span><br><span class="line">Update-Database</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 备忘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CodeFirst </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="/posts/1a4b62fe.html"/>
      <url>/posts/1a4b62fe.html</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h1><h2 id="饿汉式，线程安全"><a href="#饿汉式，线程安全" class="headerlink" title="饿汉式，线程安全"></a>饿汉式，线程安全</h2><p>是否 Lazy 初始化：否<br>是否多线程安全：是<br>描述：这种方式比较常用，但容易产生垃圾对象。<br>优点：没有加锁，执行效率会提高。<br>缺点：类加载时就初始化，浪费内存。<br>它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 Instance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;构造函数调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">Instance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h2><p>是否 Lazy 初始化：是<br>是否多线程安全：否<br>描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 所以严格意义上它并不算单例模式。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 定义为static，可以保证变量为线程安全的，即每个线程一个实例</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 _instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">Instance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _instance ?? (_instance = <span class="keyword">new</span> Singleton2());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 使用此方法销毁已创建的实例</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _instance = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h2><p>是否 Lazy 初始化：是<br>是否多线程安全：是<br>描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// / &lt;summary&gt;</span></span><br><span class="line"><span class="comment">// / 单例模式实现方式三： 推荐</span></span><br><span class="line"><span class="comment">// / 锁机制，确保多线程只产生一个实例</span></span><br><span class="line"><span class="comment">// / &lt;/summary&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 _instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> Locker = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">Instance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//没有第一重 instance == null 的话，每一次有线程进入 GetInstance()时，均会执行锁定操作来实现线程同步，</span></span><br><span class="line">        <span class="comment">//非常耗费性能 增加第一重instance ==nul成立时的情况下执行一次锁定以实现线程同步</span></span><br><span class="line">        <span class="keyword">if</span> (_instance==<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (Locker)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//Double-Check Locking 双重检查锁定</span></span><br><span class="line">                <span class="keyword">if</span> (_instance==<span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    _instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>是否 Lazy 初始化：是<br>是否多线程安全：是</p><p>描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 1 种方式不同的是：第 1 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 1 种方式就显得很合理。</p><p>在C#中，静态内部类不会在外部类被加载时自动加载。静态内部类只有在被使用时才会被加载，而不是在外部类被加载时就自动加载。<br>当你首次引用静态内部类的成员（如调用静态内部类的方法或访问静态内部类的字段）时，CLR 会加载该静态内部类。这意味着只有在需要使用静态内部类时，才会加载并初始化它。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SingletonHolder</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton4 Instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">GetInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="泛型单例"><a href="#泛型单例" class="headerlink" title="泛型单例"></a>泛型单例</h1><p>是否 Lazy 初始化：是<br>是否多线程安全：是<br>描述：泛型的懒汉式线程安全的单例模式<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 泛型单例模式的实现</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="doctag">&lt;/typeparam&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GenericSingleton</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span><span class="comment">//,new () </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> Locker = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">GetInstance</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//没有第一重 instance == null 的话，每一次有线程进入 GetInstance()时，均会执行锁定操作来实现线程同步，</span></span><br><span class="line">        <span class="comment">//非常耗费性能 增加第一重instance ==null 成立时的情况下执行一次锁定以实现线程同步</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Double-Check Locking 双重检查锁定</span></span><br><span class="line">            <span class="keyword">lock</span> (Locker)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//instance = new T();</span></span><br><span class="line">                    <span class="comment">//需要非公共的无参构造函数，不能使用new T() ,new不支持非公共的无参构造函数 </span></span><br><span class="line">                    instance = Activator.CreateInstance(<span class="keyword">typeof</span>(T), <span class="literal">true</span>) <span class="keyword">as</span> T;<span class="comment">//第二个参数防止异常：“没有为该对象定义无参数的构造函数。”</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton5</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 非公共无参构造函数，确保该类无法在其他地方实例化</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 也可以通过暴露属性获取实例</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> GenericSingleton&lt;Singleton5&gt;.GetInstance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET日志之Serilog</title>
      <link href="/posts/b188dbdb.html"/>
      <url>/posts/b188dbdb.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用Serilog.AspNetCore包 -&gt; Nuget引入Serilog.AspNetCore</p></blockquote><h2 id="配置Serilog"><a href="#配置Serilog" class="headerlink" title="配置Serilog"></a>配置Serilog</h2><p>在appsettings.json中替换原有的Logging配置，改为Serilog配置</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Serilog&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;Using&quot;</span>:  [ <span class="string">&quot;Serilog.Sinks.Console&quot;</span>, <span class="string">&quot;Serilog.Sinks.File&quot;</span> ],</span><br><span class="line"><span class="string">&quot;MinimumLevel&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Default&quot;</span>: <span class="string">&quot;Information&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Override&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Microsoft&quot;</span>: <span class="string">&quot;Warning&quot;</span>,</span><br><span class="line">    <span class="string">&quot;System&quot;</span>: <span class="string">&quot;Warning&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;WriteTo&quot;</span>: [</span><br><span class="line">    &#123; <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Console&quot;</span> &#125;,</span><br><span class="line">    &#123; </span><br><span class="line">    <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;File&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Args&quot;</span>: &#123; </span><br><span class="line">        <span class="string">&quot;path&quot;</span>: <span class="string">&quot;Logs/log-.txt&quot;</span>,</span><br><span class="line">        <span class="string">&quot;rollingInterval&quot;</span>: <span class="string">&quot;Day&quot;</span>,</span><br><span class="line">        <span class="string">&quot;rollOnFileSizeLimit&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;formatter&quot;</span>: <span class="string">&quot;Serilog.Formation.Compact.CompactJsonFormatter&quot;</span> </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;Enrich&quot;</span>: [ <span class="string">&quot;FromLogContext&quot;</span>, <span class="string">&quot;WithMachineName&quot;</span>, <span class="string">&quot;WithThreadId&quot;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在启动项中配置Serilog"><a href="#在启动项中配置Serilog" class="headerlink" title="在启动项中配置Serilog"></a>在启动项中配置Serilog</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从配置文件中读取配置Serilog</span></span><br><span class="line">builder.Host.UseSerilog((context, configuration) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    configuration.ReadFrom.Configuration(context.Configuration);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="使用Logger"><a href="#使用Logger" class="headerlink" title="使用Logger"></a>使用Logger</h2><blockquote><p>似乎Log.XXX和Log.Logger.XXX没有区别?</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在需要日志服务的地方引入命名空间</span></span><br><span class="line"><span class="keyword">using</span> Serilog;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用Log.Logger的方法记录</span></span><br><span class="line">Log.Logger.Fatal(<span class="string">&quot;&quot;</span>);</span><br><span class="line">Log.Logger.Information(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Serilog </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET中的ORM</title>
      <link href="/posts/c501a40c.html"/>
      <url>/posts/c501a40c.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C#依赖注入</title>
      <link href="/posts/53c8c838.html"/>
      <url>/posts/53c8c838.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C#Linq</title>
      <link href="/posts/f4d79c1c.html"/>
      <url>/posts/f4d79c1c.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C#特性</title>
      <link href="/posts/35f6c3bd.html"/>
      <url>/posts/35f6c3bd.html</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>单单特性其实啥用也没有，想要让特性发挥出作用需要反射配合。</p></div><h2 id="NET里的特性"><a href="#NET里的特性" class="headerlink" title=".NET里的特性"></a>.NET里的特性</h2><h3 id="Obsolete"><a href="#Obsolete" class="headerlink" title="Obsolete"></a>Obsolete</h3><h3 id="Conditional"><a href="#Conditional" class="headerlink" title="Conditional"></a>Conditional</h3><h3 id="自定义特性实现序列化时忽略某个属性"><a href="#自定义特性实现序列化时忽略某个属性" class="headerlink" title="自定义特性实现序列化时忽略某个属性"></a>自定义特性实现序列化时忽略某个属性</h3><p>自己定义一个特性非常的简单，只要继承自系统的Attribute类就行，命名以Attribute结尾，在想使用的地方加上特性就行，可以省略后面的Attribute。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = false)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BrowsableAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> Browsable &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BrowsableAttribute</span>(<span class="params"><span class="built_in">bool</span> browsable</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Browsable = browsable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IgnoreAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>AttributeUsage特性</p></blockquote><p>第一个参数： AttributeTargets 默认是All 设置特性的作用范围<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> AttributeTargets</span><br><span class="line">&#123;</span><br><span class="line">    Assembly = <span class="number">0x0001</span>,</span><br><span class="line">    Module = <span class="number">0x0002</span>,</span><br><span class="line">    Class = <span class="number">0x0004</span>,</span><br><span class="line">    Struct = <span class="number">0x0008</span>,</span><br><span class="line">    Enum = <span class="number">0x0010</span>,</span><br><span class="line">    Constructor = <span class="number">0x0020</span>,</span><br><span class="line">    Method = <span class="number">0x0040</span>,</span><br><span class="line">    Property = <span class="number">0x0080</span>,</span><br><span class="line">    Field = <span class="number">0x0100</span>,</span><br><span class="line">    Event = <span class="number">0x0200</span>,</span><br><span class="line">    Interface = <span class="number">0x0400</span>,</span><br><span class="line">    Parameter = <span class="number">0x0800</span>,</span><br><span class="line">    Delegate = <span class="number">0x1000</span>,</span><br><span class="line">    ReturnValue = <span class="number">0x2000</span>,</span><br><span class="line">    GenericParameter = <span class="number">0x4000</span>,</span><br><span class="line"></span><br><span class="line">    All = Assembly | Module | Class | Struct | Enum | Constructor |</span><br><span class="line">            Method | Property | Field | Event | Interface | </span><br><span class="line">            Parameter | Delegate | ReturnValue | GenericParameter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二个参数：AllowMultiple 默认是false 设置是否允许在同一个地方使用多次</p><p>第三个参数：Inherited 默认是false 设置是否允许被继承</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// [Browsable(false)]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">// [Browsable(true)]</span></span><br><span class="line">    [<span class="meta">Ignore</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Grade &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> grade</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = obj.GetType()</span><br><span class="line">        .GetProperties()</span><br><span class="line">        <span class="comment">// .Where(o =&gt;</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     var prop = o.GetCustomAttribute&lt;BrowsableAttribute&gt;();</span></span><br><span class="line">        <span class="comment">//     return prop is null || prop.Browsable;</span></span><br><span class="line">        <span class="comment">// &#125;)</span></span><br><span class="line">        .Where(o =&gt; o.GetCustomAttribute&lt;IgnoreAttribute&gt;() <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">        .Select(prop =&gt; <span class="keyword">new</span> &#123; name = prop.Name, <span class="keyword">value</span> = prop.GetValue(obj) &#125;)</span><br><span class="line">        .Select(o =&gt; <span class="string">$&quot;<span class="subst">&#123;o.name&#125;</span>: <span class="subst">&#123;o.<span class="keyword">value</span>&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.Join(<span class="string">&quot;\n&quot;</span>, res);</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> Student(<span class="string">&quot;Hello&quot;</span>, <span class="number">1024</span>);</span><br><span class="line"><span class="keyword">var</span> s = Serialize(student);</span><br><span class="line">Console.WriteLine(s);</span><br></pre></td></tr></table></figure><p>输出如下所示：</p><blockquote><p>Name: Hello</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#反射</title>
      <link href="/posts/f7500138.html"/>
      <url>/posts/f7500138.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> CSharp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Abp学习</title>
      <link href="/posts/ba422dad.html"/>
      <url>/posts/ba422dad.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习</title>
      <link href="/posts/8434e219.html"/>
      <url>/posts/8434e219.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库范式</title>
      <link href="/posts/91a921e9.html"/>
      <url>/posts/91a921e9.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式 1NF"></a>第一范式 1NF</h2><blockquote><p>强调的是列的原子性，即列不能够再分成其他几列。<br>考虑这样一个表：[联系人] (姓名，性别，电话)<br>如果在实际场景中，一个联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF。<br>要符合 1NF，我们只需把列(电话)拆分，即：[联系人] (姓名,性别,家庭电话,公司电话). 1NF 很好辨别,但是 2NF 和 3NF 就容易搞混淆.</p></blockquote><h2 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式 2NF"></a>第二范式 2NF</h2><blockquote><p><strong>首先是 1NF</strong>，另外包含两部分内容，<strong>一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分</strong>.<br>考虑一个订单明细表：[OrderDetail]（OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName）。<br>因为我们知道在一个订单中可以订购多种产品，所以单单一个 OrderID 是不足以成为主键的，主键应该是(OrderID，ProductID).<br>显而易见Discount,Quantity,完全依赖于主键(OderID,ProductID),而UnitPrice,ProductName<br>只依赖于 ProductID。所以 OrderDetail 表不符合 2NF。不符合 2NF 的设计容易产生冗余数据。<br>可以把[OrderDetail]表拆分为[OrderDetail]（OrderID，ProductID，Discount，Quantity）和[Product]（ProductID，UnitPrice，ProductName）来消除原订单表中UnitPrice，ProductName多次重复的情况。</p></blockquote><h2 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式 3NF"></a>第三范式 3NF</h2><blockquote><p><strong>首先是 2NF</strong>，另外非主键列必须直接依赖于主键，不能存在传递依赖。即<strong>不能存在：非主键列 A 依赖于非主键列 B，非主键列 B依赖于主键的情况</strong>。考虑一个订单表[Order] (OrderID,OrderDate,CustomerID,CustomerName,CustomerAddr,CustomerCity)主键是(OrderID)其中 OrderDate,CustomerID,CustomerName,CustomerAddr,CustomerCity等非主键列都完全依赖于主键(OrderID),所以符合2NF. 不过问题是CustomerName,CustomerAddr,CustomerCity直接依赖的是CustomerID(非主键列),而不是直接依赖于主键,它是通过传递才依赖于主键,所以不符合 3NF。通过拆分[Order]为[Order]（OrderID，OrderDate，CustomerID）和[Customer]（CustomerID，CustomerName，CustomerAddr，CustomerCity）从而达到 3NF。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库学习</title>
      <link href="/posts/b4fe5633.html"/>
      <url>/posts/b4fe5633.html</url>
      
        <content type="html"><![CDATA[<h2 id="排序与分页"><a href="#排序与分页" class="headerlink" title="排序与分页"></a>排序与分页</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 多列排序</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,salary,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department_id <span class="keyword">DESC</span>,salary <span class="keyword">ASC</span></span><br></pre></td></tr></table></figure><div class="note default flat"><p>在对多列进⾏排序的时候，⾸先排序的第⼀列必须有相同的列值，才会对第⼆列进⾏排序。如果第⼀<br>列数据中所有值都是唯⼀的，将不再对第⼆列进⾏排序。</p></div><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 LIMIT <span class="number">20</span>,<span class="number">10</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">10</span>;(Mysql <span class="operator">&gt;</span> <span class="number">8.0</span>)</span><br></pre></td></tr></table></figure><div class="note warning flat"><p>深分页该怎么办</p></div><hr><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="等值连接VS非等值连接"><a href="#等值连接VS非等值连接" class="headerlink" title="等值连接VS非等值连接"></a>等值连接VS非等值连接</h4><div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tab-1">等值连接</button></li><li class="tab"><button type="button" data-href="#tab-2">非等值连接</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tab-1"><p>等值连接（Equi-Join）基于两个表之间的相等匹配条件来组合它们的行,通常使用在需要从两个表中选择相关数据的查询中。</p><p>等值连接使用一个等于号（=）来比较两个表中的列。当两个表中的列具有相同的值时，它们的行就会被组合在一起。例如，下面的 SQL 查询使用等值连接来将 “orders” 表中的 “customer_id” 列与 “customers” 表中的 “customer_id” 列匹配：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">JOIN</span> customers</span><br><span class="line"><span class="keyword">ON</span> orders.customer_id <span class="operator">=</span> customers.customer_id;</span><br></pre></td></tr></table></figure><p>这将返回一个包含 “orders” 表和 “customers” 表中匹配 “customer_id” 的行的结果集。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tab-2"><p>非等值连接（Non-Equi Join）基于两个表之间的不等匹配条件来组合它们的行,通常使用在需要从两个表中选择相关数据的查询中。</p><p>非等值连接使用不等于号（&lt;&gt;、!=、&lt;、&gt;、&lt;=、&gt;=）等比较运算符来比较两个表中的列。当两个表中的列不具有相同的值时，它们的行就会被组合在一起。例如，下面的 SQL 查询使用非等值连接来将 “orders” 表中的 “order_date” 列与 “calendar” 表中的 “date” 列匹配：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">JOIN</span> calendar</span><br><span class="line"><span class="keyword">ON</span> orders.order_date <span class="keyword">BETWEEN</span> calendar.date <span class="keyword">AND</span> calendar.date <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，”orders” 表中的 “order_date” 列被匹配到了 “calendar” 表中的 “date” 列和 “date” + INTERVAL 1 DAY 列之间的范围内。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p><mark class="hl-label blue">拓展1：</mark> 区分重复的列名</p><ol><li>多个表中有相同列时，必须在列名之前加上表名前缀。</li></ol><p><mark class="hl-label blue">拓展2：</mark> 表的别名</p><ol><li>使⽤别名可以<mark class="hl-label green">简化查询</mark> 。</li><li>列名前使⽤表名前缀可以<mark class="hl-label green">提⾼查询效率</mark> 。</li></ol><p><mark class="hl-label blue">拓展3：</mark> 连接多个表</p><ol><li>连接n个表<mark class="hl-label red">⾄少需要n-1个连接条件</mark> 。</li></ol></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name,e.salary,j.grade_level</span><br><span class="line"><span class="keyword">FROM</span> employees e,job_grades j</span><br><span class="line"><span class="keyword">WHERE</span> e.`salary` <span class="operator">&gt;=</span> j.`lowest_sal` <span class="keyword">AND</span> e.`salary` <span class="operator">&lt;=</span> j.`highest_sal`;</span><br></pre></td></tr></table></figure><hr><h4 id="自连接VS非自连接"><a href="#自连接VS非自连接" class="headerlink" title="自连接VS非自连接"></a>自连接VS非自连接</h4><div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tab-1">自连接</button></li><li class="tab"><button type="button" data-href="#tab-2">非自连接</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tab-1"><p>自连接（Self Join）是指将一个表与自身进行连接。自连接通常用于需要在同一表中比较或匹配不同行的情况。</p><p>自连接可以通过给表指定不同的别名来实现。例如，下面的 SQL 查询使用自连接来查找 “employees” 表中每个员工的经理：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.employee_name, m.employee_name <span class="keyword">AS</span> manager_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">JOIN</span> employees m</span><br><span class="line"><span class="keyword">ON</span> e.manager_id <span class="operator">=</span> m.employee_id;</span><br></pre></td></tr></table></figure><p>在这个例子中，”employees” 表被自连接为两个不同的实例，分别用 “e” 和 “m” 作为别名。连接条件是 “e.manager_id = m.employee_id”，它将 “employees” 表中的每个员工与其对应的经理匹配。这将返回一个包含每个员工姓名和其经理姓名的结果集。</p><p>需要注意的是，在进行自连接时，需要确保连接条件不会将同一行与自身进行匹配，否则可能会导致无限循环或错误的结果。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tab-2"><p>非自连接可以使用各种连接类型，例如内连接（Inner Join）、左连接（Left Join）、右连接（Right Join）和全连接（Full Join），具体取决于需要的结果集。连接条件通常是两个表中的列之间的相等匹配条件。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h4 id="内连接VS外连接"><a href="#内连接VS外连接" class="headerlink" title="内连接VS外连接"></a>内连接VS外连接</h4><ul><li>内连接: 合并具有同⼀列的两个以上的表的⾏, 结果集中不包含⼀个表与另⼀个表不匹配的⾏</li><li>外连接: 两个表在连接过程中除了返回满⾜连接条件的⾏以外还返回左（或右）表中不满⾜条件的⾏，<br>这种连接称为左（或右） 外连接。没有匹配的⾏时, 结果表中相应的列为空(NULL)。<br>如果是左外连接，则连接条件中左边的表也称为 主表 ，右边的表称为 从表 。<br>如果是右外连接，则连接条件中右边的表也称为 主表 ，左边的表称为 从表 。</li></ul><blockquote><p>在使用 left jion 时，on 和 where 条件的区别如下：<br>1、on 条件是在生成临时表时使用的条件，它不管 on 中的条件是否为真，都会返回左边表中的记录。<br>2、where 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 left join 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</p></blockquote><h2 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h2><p>TODO</p><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><div class="note info flat"><p>聚合函数（Aggregate Function）是一组用于计算多个行的值并返回单个值的函数。聚合函数通常用于统计和分析数据，例如计算平均值、最大值、最小值、总和等。</p></div><h3 id="AVG-SUM-MIN-MAX函数函数"><a href="#AVG-SUM-MIN-MAX函数函数" class="headerlink" title="AVG/SUM/MIN/MAX函数函数"></a>AVG/SUM/MIN/MAX函数函数</h3><blockquote><p>下面的 SQL 查询使用 AVG 函数计算 “employees” 表中所有员工的平均工资：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(salary),SUM(salary),MIN(salary),MAX(salary)</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><br>在这个例子中，AVG 函数计算 “employees” 表中所有员工的工资平均值，并将结果作为单个值返回。</p></blockquote><h3 id="COUNT函数"><a href="#COUNT函数" class="headerlink" title="COUNT函数"></a>COUNT函数</h3><blockquote><p>COUNT(*)返回表中记录总数，适⽤于任意数据类型。<br>COUNT(expr) 返回expr不为NULL的记录总数。</p></blockquote><h3 id="Group-By函数"><a href="#Group-By函数" class="headerlink" title="Group By函数"></a>Group By函数</h3><h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>领域驱动设计</title>
      <link href="/posts/209eb15b.html"/>
      <url>/posts/209eb15b.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习领域驱动设计的笔记</p></blockquote><h3 id="领域"><a href="#领域" class="headerlink" title="领域"></a>领域</h3><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      <categories>
          
          <category> 领域驱动设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDD </tag>
            
            <tag> 领域驱动设计 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于</p></blockquote>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/modify.css"/>
      <url>/css/modify.css</url>
      
        <content type="html"><![CDATA[#page-header,#page-header:before {  background: transparent !important;}#page-header.post-bg,#page-header.not-home-page {  height: 280px !important;}#page-header #post-info {  bottom: 40px !important;}#page-header #page-site-info {  top: 140px !important;}@media screen and (max-width: 768px) {  #page-header.not-home-page {    height: 200px !important;  }  #page-header #post-info {    bottom: 10px !important;  }  #page-header #page-site-info {    top: 100px !important;  }}.top-img {  height: 250px;  margin: -50px -40px 50px;  border-top-left-radius: inherit;  border-top-right-radius: inherit;  background-position: center center;  background-size: cover;  -webkit-transition: all 0.3s;  -moz-transition: all 0.3s;  -o-transition: all 0.3s;  -ms-transition: all 0.3s;  transition: all 0.3s;}@media screen and (max-width: 768px) {  .top-img {    height: 230px;    margin: -36px -14px 36px;  }}[data-theme='dark'] .top-img {  filter: brightness(0.8);}#footer:before {  background-color: rgba(255,255,255,0.5);}[data-theme='dark'] #footer:before {  background-color: rgba(0,0,0,0.5);}#footer-wrap,#footer-wrap a {  color: #111;  -webkit-transition: unset;  -moz-transition: unset;  -o-transition: unset;  -ms-transition: unset;  transition: unset;}[data-theme='dark'] #footer-wrap,[data-theme='dark'] #footer-wrap a {  color: var(--light-grey);}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[setInterval(() => {    let create_time = Math.round(new Date('2023-06-11 00:00:00').getTime() / 1000); //在此行修改建站时间    let timestamp = Math.round((new Date().getTime()) / 1000);    let second = timestamp - create_time;    let time = new Array(0, 0, 0, 0, 0);      var nol = function(h){      return h>9?h:'0'+h;    }    if (second >= 365 * 24 * 3600) {      time[0] = parseInt(second / (365 * 24 * 3600));      second %= 365 * 24 * 3600;    }    if (second >= 24 * 3600) {      time[1] = parseInt(second / (24 * 3600));      second %= 24 * 3600;    }    if (second >= 3600) {      time[2] = nol(parseInt(second / 3600));      second %= 3600;    }    if (second >= 60) {      time[3] = nol(parseInt(second / 60));      second %= 60;    }    if (second > 0) {      time[4] = nol(second);    }    if ((Number(time[2])<22) && (Number(time[2])>7)){      currentTimeHtml ="<img class='boardsign' src='https://img.shields.io/badge/Splay-营业中-6adea8?style=social&logo=cakephp' title='距离百年老店也就差不到一百年~'><div id='runtime'>" + time[0] + ' YEAR ' + time[1] + ' DAYS ' + time[2] + ' : ' + time[3] + ' : ' + time[4] + '</div>';    }    else{      currentTimeHtml ="<img class='boardsign' src='https://img.shields.io/badge/Splay-打烊了-6adea8?style=social&logo=coffeescript' title='这个点了应该去睡觉啦，熬夜对身体不好哦'><div id='runtime'>" + time[0] + ' YEAR ' + time[1] + ' DAYS ' + time[2] + ' : ' + time[3] + ' : ' + time[4] + '</div>';    }    document.getElementById("workboard").innerHTML = currentTimeHtml;  }, 1000);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
